% Regression tests for the XCP_CAN
~ python3_only vcan_socket needs_root linux

# More information at http://www.secdev.org/projects/UTscapy/

############
############

+ Basic operations
= Imports

import threading
import time
from subprocess import call

import six

from scapy.consts import LINUX
from scapy.contrib.automotive.xcp.cto_commands_master import Connect, TransportLayerCmd, TransportLayerCmdGetSlaveId
from scapy.contrib.automotive.xcp.scanner import XCPOnCANScanner
from scapy.contrib.automotive.xcp.xcp import CTORequest, XCPOnCAN, CTOResponse, ConnectPositiveResponse, TransportLayerCmdGetSlaveIdResponse, GenericResponse
from scapy.contrib.cansocket_python_can import CANSocket
from scapy.main import load_layer

= Load module

load_layer("can")
load_contrib("automotive.xcp.xcp")

= Global variables

iface0 = "vcan0"

= Initialize a virtual CAN interface

print('setting up CAN')

if 0 != call("cansend %s 000#" % iface0, shell=True):
    # vcan0 is not enabled
    if 0 != call("sudo modprobe vcan", shell=True):
        raise Exception("modprobe vcan failed")
    if 0 != call("sudo ip link add name %s type vcan" % iface0, shell=True):
        print("add %s failed: Maybe it was already up?" % iface0)
    if 0 != call("sudo ip link set dev %s up" % iface0, shell=True):
        raise Exception("could not bring up %s" % iface0)

if 0 != call("cansend %s 000#" % iface0, shell=True):
    raise Exception("cansend doesn't work")

print("CAN should work now")

new_can_socket0 = lambda: CANSocket(bustype='virtual', channel=iface0, timeout=0.01)

if six.PY3 and LINUX:
    new_can_socket0 = lambda: CANSocket(iface0)

if "python_can" in CANSocket.__module__:
    new_can_socket0 = lambda: CANSocket(bustype='socketcan', channel=iface0, bitrate=250000, timeout=0.01)


= verify CAN Socket creation works
s = new_can_socket0()
s.close()

+ Tests on a virtual CAN-Bus


= CONNECT
sock1 = new_can_socket0()
sock2 = new_can_socket0()

sock1.basecls = XCPOnCAN
sock2.basecls = XCPOnCAN

def ecu():
    pkts = sock2.sniff(count=1, timeout=5)
    if len(pkts) == 1:
        response = XCPOnCAN(identifier=0x700) / CTOResponse(packet_code="RES") / ConnectPositiveResponse(
            b'\x15\xC0\x08\x08\x00\x10\x10')
        sock2.send(response)

thread = threading.Thread(target=ecu)
thread.start()
time.sleep(0.1)
pkt = XCPOnCAN(identifier=0x700) / CTORequest(pid="CONNECT") / Connect(connection_mode="NORMAL")
ans = sock1.sr1(pkt, timeout=3)
thread.join()
sock1.close()
sock2.close()
ans.show()

assert ans.identifier == 0x700
cto_response = ans["CTOResponse"]
assert cto_response.packet_code == 0xff

connect_response = cto_response["ConnectPositiveResponse"]

assert connect_response.resource == 0x15
assert connect_response.comm_mode_basic == 0xC0
assert connect_response.max_cto == 8
assert connect_response.max_cto == 8

assert connect_response.xcp_protocol_layer_version_number_msb == 0x10
assert connect_response.xcp_transport_layer_version_number_msb == 0x10

+ Tests XCPonCAN Scanner

= xcp can scanner with broadcast ID
broadcast_identifier = 50
ecu_xcp_identifier = 30
ecu_response_identifier = 31

id_request = XCPOnCAN(identifier=broadcast_identifier) / CTORequest(
    pid="TRANSPORT_LAYER_CMD") / TransportLayerCmd(
    sub_command_code=0xFF) / TransportLayerCmdGetSlaveId()
id_response = XCPOnCAN(
    identifier=ecu_response_identifier) / CTOResponse() / TransportLayerCmdGetSlaveIdResponse(
    can_identifier=ecu_xcp_identifier)

assert id_response.answers(id_request) == True
sock1 = new_can_socket0()
sock1.basecls = XCPOnCAN

def ecu():
    pkts = sock1.sniff(count=1, timeout=5)
    if len(pkts) == 1:
        sock1.send(id_response)

thread = threading.Thread(target=ecu)
thread.start()
time.sleep(0.1)

sock2 = new_can_socket0()
sock2.basecls = XCPOnCAN

scanner = XCPOnCANScanner(sock2, broadcast_id=broadcast_identifier)
result = scanner.start_scan()

assert result[0]["slave_id"] == ecu_xcp_identifier
assert result[0]["response_id"] == ecu_response_identifier
thread.join()
sock1.close()
sock2.close()

= xcp can scanner broadcast ID-Range
broadcast_identifier_range = (50, 54)
ecu_xcp_identifier_1 = 10
ecu_response_identifier_1 = 11
ecu_xcp_identifier_2 = 20
ecu_response_identifier_2 = 21

id_response_1 = XCPOnCAN(
    identifier=ecu_response_identifier_1) / CTOResponse() / TransportLayerCmdGetSlaveIdResponse(
    can_identifier=ecu_xcp_identifier_1)
id_response_2 = XCPOnCAN(
    identifier=ecu_response_identifier_2) / CTOResponse() / TransportLayerCmdGetSlaveIdResponse(
    can_identifier=ecu_xcp_identifier_2)

id_response_3 = XCPOnCAN(
    identifier=30) / CTOResponse() / GenericResponse(b"\x00\x00")
id_response_4 = XCPOnCAN(
    identifier=40) / CTOResponse() / GenericResponse(b"\x00\x00")

sock1 = new_can_socket0()
sock1.basecls = XCPOnCAN

def ecu():
    sock1.sniff(count=1)
    sock1.send(id_response_3)
    sock1.sniff(count=1)
    sock1.send(id_response_3)
    sock1.send(id_response_4)
    sock1.sniff(count=2)
    sock1.send(id_response_1)
    sock1.send(id_response_2)

thread = threading.Thread(target=ecu)
thread.start()
time.sleep(0.1)

sock2 = new_can_socket0()
sock2.basecls = XCPOnCAN

scanner = XCPOnCANScanner(sock2, broadcast_id_range=broadcast_identifier_range)
result = scanner.start_scan()

assert len(result) == 2
assert result[0]["slave_id"] == ecu_xcp_identifier_1
assert result[0]["response_id"] == ecu_response_identifier_1
assert result[1]["slave_id"] == ecu_xcp_identifier_2
assert result[1]["response_id"] == ecu_response_identifier_2
sock1.close()
sock2.close()

+ Cleanup
= Delete vcan interfaces
~ vcan_socket needs_root linux

if 0 != call("sudo ip link delete %s" % iface0, shell=True):
    raise Exception("%s could not be deleted" % iface0)
